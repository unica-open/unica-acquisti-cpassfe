/*
* SPDX-FileCopyrightText: Copyright 2019 - 2020 | CSI Piemonte
* SPDX-License-Identifier: EUPL-1.2
*/
/**
 * Contabilità passiva
 * API per il backend della suite di contabilità passiva.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApiError } from '../model/apiError';
import { DocumentoSpesa } from '../model/documentoSpesa';
import { Elaborazione } from '../model/elaborazione';
import { Fornitore } from '../model/fornitore';
import { ListinoFornitore } from '../model/listinoFornitore';
import { MetadatiFunzione } from '../model/metadatiFunzione';
import { PagedResponseFornitore } from '../model/pagedResponseFornitore';
import { PagedResponseSettore } from '../model/pagedResponseSettore';
import { Settore } from '../model/settore';
import { SettoreIndirizzo } from '../model/settoreIndirizzo';
import { Ufficio } from '../model/ufficio';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration, FormParams }                         from '../configuration';
import { CommonServiceInterface }                            from './common.serviceInterface';


@Injectable()
export class CommonService implements CommonServiceInterface {

    protected basePath = 'http://localhost:8080/cpassbe/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * Restituisce i metadati della specifica funzione
     * @param modulo modulo.
     * @param funzione funzione.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMetadatiByModuoloFunzione(modulo: string, funzione: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MetadatiFunzione>>;
    public getMetadatiByModuoloFunzione(modulo: string, funzione: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MetadatiFunzione>>>;
    public getMetadatiByModuoloFunzione(modulo: string, funzione: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MetadatiFunzione>>>;
    public getMetadatiByModuoloFunzione(modulo: string, funzione: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (modulo === null || modulo === undefined) {
            throw new Error('Required parameter modulo was null or undefined when calling getMetadatiByModuoloFunzione.');
        }
        if (funzione === null || funzione === undefined) {
            throw new Error('Required parameter funzione was null or undefined when calling getMetadatiByModuoloFunzione.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<MetadatiFunzione>>(`${this.basePath}/common/metadati/${encodeURIComponent(String(modulo))}/${encodeURIComponent(String(funzione))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Restituisce sla lista dei settori parenti
     * @param id_settore id settore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMySectorFamily(id_settore: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Settore>>;
    public getMySectorFamily(id_settore: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Settore>>>;
    public getMySectorFamily(id_settore: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Settore>>>;
    public getMySectorFamily(id_settore: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id_settore === null || id_settore === undefined) {
            throw new Error('Required parameter id_settore was null or undefined when calling getMySectorFamily.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Settore>>(`${this.basePath}/common/settore-padre/${encodeURIComponent(String(id_settore))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * estrai ordinamento
     * @param modulo modulo.
     * @param funzione funzione.
     * @param tipo tipo.
     * @param listMetadatiFunzione 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrdinamentoByModuloFunzioneTipo(modulo: string, funzione: string, tipo: 'JPQL' | 'SQL', listMetadatiFunzione: Array<MetadatiFunzione>, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getOrdinamentoByModuloFunzioneTipo(modulo: string, funzione: string, tipo: 'JPQL' | 'SQL', listMetadatiFunzione: Array<MetadatiFunzione>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getOrdinamentoByModuloFunzioneTipo(modulo: string, funzione: string, tipo: 'JPQL' | 'SQL', listMetadatiFunzione: Array<MetadatiFunzione>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getOrdinamentoByModuloFunzioneTipo(modulo: string, funzione: string, tipo: 'JPQL' | 'SQL', listMetadatiFunzione: Array<MetadatiFunzione>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (modulo === null || modulo === undefined) {
            throw new Error('Required parameter modulo was null or undefined when calling getOrdinamentoByModuloFunzioneTipo.');
        }
        if (funzione === null || funzione === undefined) {
            throw new Error('Required parameter funzione was null or undefined when calling getOrdinamentoByModuloFunzioneTipo.');
        }
        if (tipo === null || tipo === undefined) {
            throw new Error('Required parameter tipo was null or undefined when calling getOrdinamentoByModuloFunzioneTipo.');
        }
        if (listMetadatiFunzione === null || listMetadatiFunzione === undefined) {
            throw new Error('Required parameter listMetadatiFunzione was null or undefined when calling getOrdinamentoByModuloFunzioneTipo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/common/ordinamento/${encodeURIComponent(String(modulo))}/funzione/${encodeURIComponent(String(funzione))}/tipo/${encodeURIComponent(String(tipo))}`,
            listMetadatiFunzione,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Restituisce l&#39;alberatura Settore per ente.
     * @param id_ente id ente.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSettoreTreeByEnte(id_ente: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Settore>>;
    public getSettoreTreeByEnte(id_ente: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Settore>>>;
    public getSettoreTreeByEnte(id_ente: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Settore>>>;
    public getSettoreTreeByEnte(id_ente: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id_ente === null || id_ente === undefined) {
            throw new Error('Required parameter id_ente was null or undefined when calling getSettoreTreeByEnte.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Settore>>(`${this.basePath}/common/settore/${encodeURIComponent(String(id_ente))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Restituisce gli Uffici del settore registrati su sistema.
     * @param id_settore id settore.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUfficiBySettore(id_settore: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Ufficio>>;
    public getUfficiBySettore(id_settore: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Ufficio>>>;
    public getUfficiBySettore(id_settore: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Ufficio>>>;
    public getUfficiBySettore(id_settore: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id_settore === null || id_settore === undefined) {
            throw new Error('Required parameter id_settore was null or undefined when calling getUfficiBySettore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Ufficio>>(`${this.basePath}/common/ufficio/${encodeURIComponent(String(id_settore))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Restituisce se un settore è parente di un&#39;altro.
     * @param id_settore id settore.
     * @param id_settore_parent id settore parent.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public isMySectorParent(id_settore: string, id_settore_parent: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public isMySectorParent(id_settore: string, id_settore_parent: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public isMySectorParent(id_settore: string, id_settore_parent: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public isMySectorParent(id_settore: string, id_settore_parent: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id_settore === null || id_settore === undefined) {
            throw new Error('Required parameter id_settore was null or undefined when calling isMySectorParent.');
        }
        if (id_settore_parent === null || id_settore_parent === undefined) {
            throw new Error('Required parameter id_settore_parent was null or undefined when calling isMySectorParent.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/common/settore/${encodeURIComponent(String(id_settore))}/parente/${encodeURIComponent(String(id_settore_parent))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * inserisce listino fornitore su sistema.
     * @param listinoFornitore 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postListinoFornitore(listinoFornitore: ListinoFornitore, observe?: 'body', reportProgress?: boolean): Observable<PagedResponseFornitore>;
    public postListinoFornitore(listinoFornitore: ListinoFornitore, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResponseFornitore>>;
    public postListinoFornitore(listinoFornitore: ListinoFornitore, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResponseFornitore>>;
    public postListinoFornitore(listinoFornitore: ListinoFornitore, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (listinoFornitore === null || listinoFornitore === undefined) {
            throw new Error('Required parameter listinoFornitore was null or undefined when calling postListinoFornitore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PagedResponseFornitore>(`${this.basePath}/common/listino-fornitore`,
            listinoFornitore,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca documenti spesa presenti a sistema.
     * @param ds 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaDocumentoSpesa(ds: DocumentoSpesa, observe?: 'body', reportProgress?: boolean): Observable<Array<DocumentoSpesa>>;
    public postRicercaDocumentoSpesa(ds: DocumentoSpesa, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DocumentoSpesa>>>;
    public postRicercaDocumentoSpesa(ds: DocumentoSpesa, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DocumentoSpesa>>>;
    public postRicercaDocumentoSpesa(ds: DocumentoSpesa, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (ds === null || ds === undefined) {
            throw new Error('Required parameter ds was null or undefined when calling postRicercaDocumentoSpesa.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<DocumentoSpesa>>(`${this.basePath}/common/ricerca/documento-spesa`,
            ds,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca documenti spesa presenti a sistema con stato ripartibile
     * @param ds 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaDocumentoSpesaRipartibile(ds: DocumentoSpesa, observe?: 'body', reportProgress?: boolean): Observable<Array<DocumentoSpesa>>;
    public postRicercaDocumentoSpesaRipartibile(ds: DocumentoSpesa, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DocumentoSpesa>>>;
    public postRicercaDocumentoSpesaRipartibile(ds: DocumentoSpesa, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DocumentoSpesa>>>;
    public postRicercaDocumentoSpesaRipartibile(ds: DocumentoSpesa, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (ds === null || ds === undefined) {
            throw new Error('Required parameter ds was null or undefined when calling postRicercaDocumentoSpesaRipartibile.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<DocumentoSpesa>>(`${this.basePath}/common/ricerca/documento-spesa-ripartibile`,
            ds,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca elaborazioni su sistema locale
     * @param elaborazione 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaElaborazioneProgramma(elaborazione: Elaborazione, observe?: 'body', reportProgress?: boolean): Observable<Array<Elaborazione>>;
    public postRicercaElaborazioneProgramma(elaborazione: Elaborazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Elaborazione>>>;
    public postRicercaElaborazioneProgramma(elaborazione: Elaborazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Elaborazione>>>;
    public postRicercaElaborazioneProgramma(elaborazione: Elaborazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (elaborazione === null || elaborazione === undefined) {
            throw new Error('Required parameter elaborazione was null or undefined when calling postRicercaElaborazioneProgramma.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<Elaborazione>>(`${this.basePath}/common/ricerca/elaborazione-programma`,
            elaborazione,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca fornitori su sistema.
     * @param fornitore 
     * @param offset Il numero di record da ignorare prima di iniziare a raccogliere i risultati.
     * @param limit Il numero di record da restituire.
     * @param sort Il campo di sort.
     * @param direction La direzione di sort.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaFornitore(fornitore: Fornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'body', reportProgress?: boolean): Observable<PagedResponseFornitore>;
    public postRicercaFornitore(fornitore: Fornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResponseFornitore>>;
    public postRicercaFornitore(fornitore: Fornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResponseFornitore>>;
    public postRicercaFornitore(fornitore: Fornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fornitore === null || fornitore === undefined) {
            throw new Error('Required parameter fornitore was null or undefined when calling postRicercaFornitore.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters = queryParameters.set('direction', <any>direction);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PagedResponseFornitore>(`${this.basePath}/common/ricerca/fornitore`,
            fornitore,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca fornitori su sistema locale
     * @param fornitore 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaFornitoreInterno(fornitore: Fornitore, observe?: 'body', reportProgress?: boolean): Observable<Array<Fornitore>>;
    public postRicercaFornitoreInterno(fornitore: Fornitore, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Fornitore>>>;
    public postRicercaFornitoreInterno(fornitore: Fornitore, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Fornitore>>>;
    public postRicercaFornitoreInterno(fornitore: Fornitore, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fornitore === null || fornitore === undefined) {
            throw new Error('Required parameter fornitore was null or undefined when calling postRicercaFornitoreInterno.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<Fornitore>>(`${this.basePath}/common/ricerca/fornitore-interno`,
            fornitore,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca listino fornitori su sistema.
     * @param listinoFornitore 
     * @param offset Il numero di record da ignorare prima di iniziare a raccogliere i risultati.
     * @param limit Il numero di record da restituire.
     * @param sort Il campo di sort.
     * @param direction La direzione di sort.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaListinoFornitore(listinoFornitore: ListinoFornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'body', reportProgress?: boolean): Observable<PagedResponseFornitore>;
    public postRicercaListinoFornitore(listinoFornitore: ListinoFornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResponseFornitore>>;
    public postRicercaListinoFornitore(listinoFornitore: ListinoFornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResponseFornitore>>;
    public postRicercaListinoFornitore(listinoFornitore: ListinoFornitore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (listinoFornitore === null || listinoFornitore === undefined) {
            throw new Error('Required parameter listinoFornitore was null or undefined when calling postRicercaListinoFornitore.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters = queryParameters.set('direction', <any>direction);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PagedResponseFornitore>(`${this.basePath}/common/ricerca/listino-fornitore`,
            listinoFornitore,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca settori su sistema.
     * @param settore 
     * @param offset Il numero di record da ignorare prima di iniziare a raccogliere i risultati.
     * @param limit Il numero di record da restituire.
     * @param sort Il campo di sort.
     * @param direction La direzione di sort.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaSettore(settore: Settore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'body', reportProgress?: boolean): Observable<PagedResponseSettore>;
    public postRicercaSettore(settore: Settore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResponseSettore>>;
    public postRicercaSettore(settore: Settore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResponseSettore>>;
    public postRicercaSettore(settore: Settore, offset?: number, limit?: number, sort?: string, direction?: 'asc' | 'desc' | '', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (settore === null || settore === undefined) {
            throw new Error('Required parameter settore was null or undefined when calling postRicercaSettore.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters = queryParameters.set('direction', <any>direction);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PagedResponseSettore>(`${this.basePath}/common/settore/ricerca`,
            settore,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Ricerca indirizzi su sistema.
     * @param settore 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaSettoreIndirizzo(settore: Settore, observe?: 'body', reportProgress?: boolean): Observable<Array<SettoreIndirizzo>>;
    public postRicercaSettoreIndirizzo(settore: Settore, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SettoreIndirizzo>>>;
    public postRicercaSettoreIndirizzo(settore: Settore, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SettoreIndirizzo>>>;
    public postRicercaSettoreIndirizzo(settore: Settore, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (settore === null || settore === undefined) {
            throw new Error('Required parameter settore was null or undefined when calling postRicercaSettoreIndirizzo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<SettoreIndirizzo>>(`${this.basePath}/common/settore/ricerca/indirizzi-settore`,
            settore,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Test di parsing mappa.
     * @param preferenze 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postSavePreferenze(preferenze: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postSavePreferenze(preferenze: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postSavePreferenze(preferenze: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postSavePreferenze(preferenze: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (preferenze === null || preferenze === undefined) {
            throw new Error('Required parameter preferenze was null or undefined when calling postSavePreferenze.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/common/preferenze/save`,
            preferenze,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
